---
title: "human_probability_stats"
author: "Tommy Botch"
date: "2024-11-15"
output: html_document
---

# Setup environment

## Load packages

```{r}
# remove all variables
rm(list=ls()) 

# install.packages(c("lmerTest", "emmeans", "glue", "ggeffects", "ggplot2", 
#                    "ggsignif", "ggpattern", "viridis", "forcats", "dplyr",
#                    "stringr", "tools", "lmer4", "combinat", "ggpubr", "report",
#                    "rcompanion", "sjPlot", "glmmTMB", "DHARMa", "tidyverse"))

library(lmerTest)
library(emmeans)
library(glue)
library(ggeffects)
library(ggplot2)
library(sjPlot)
library(report)
library(rcompanion)
library(sjPlot)

library(DHARMa)
library(glmmTMB)
library(tidyverse)
library(performance)
library(ordinal)
```

## Prepare directories

Set up directories - since we're doing this locally (and mounting the server), 
we're going to use a different base_dir

```{r}

base_dir<-'/Volumes/FinnLab/tommy/isc_asynchrony_behavior/derivatives/'
results_dir<-glue('{base_dir}results/behavioral/')
plots_dir <- glue('{base_dir}plots/final/')

```

## Functions

```{r}
# Function to convert specified columns to factors
convert_columns_to_factors <- function(df, columns_to_convert) {
  # Check if all specified columns exist in the dataframe
  if (!all(columns_to_convert %in% names(df))) {
    missing_cols <- columns_to_convert[!columns_to_convert %in% names(df)]
    stop(paste("The following columns do not exist in the dataframe:", 
               paste(missing_cols, collapse = ", ")))
  }
  
  # Convert each specified column to factor
  for (col in columns_to_convert) {
    df[[col]] <- factor(df[[col]])
  }
  
  return(df)
}

# Function to extract p-values and test statistics
extract_lme_results <- function(task, df_results, formula, include_intercept = FALSE) {
  # Subset data for the specific task
  df_task <- df_results[df_results$task == task,]
  
  # Fit the linear mixed-effects model
  task_model <- lmer(formula, data = df_task, REML = TRUE)
  
  # Extract summary information
  model_summary <- summary(task_model)
  
  # Create results dataframe
  results_df <- data.frame(
    task = task,
    effect = rownames(model_summary$coefficients),
    estimate = model_summary$coefficients[, "Estimate"],
    std_error = model_summary$coefficients[, "Std. Error"],
    t_value = model_summary$coefficients[, "t value"],
    p_value = formatC(model_summary$coefficients[, "Pr(>|t|)"], format = "e", digits = 3)
  )
  
  # Optionally filter out intercept
  if (!include_intercept) {
    results_df <- results_df[results_df$effect != "(Intercept)", ]
  }
  
  return(results_df)
}

```

# Run human participant analysis

## Data loading

Load data and set factor columns 

```{r}

# Load the results file
results_fn<-glue('{results_dir}all-task_group-analyzed-behavior_human-lemmatized.csv')
df_results <- read.csv(results_fn)

# Set the variable types
factor_columns <- c('modality', 'ground_truth', 'word_index', 'top_pred', 'task')
df_results <- convert_columns_to_factors(df_results, factor_columns)
df_results

# # subject model for accuracy --> test if audio > text
# audio_greater_text <- c(1,-1)
# contrasts(df_results$modality) <- cbind(audio_greater_text)

# set order of variables
df_results$modality <- factor(df_results$modality, levels = 
                                  c("video", "audio", "text"))

# subject model for accuracy --> test if audio > text
audio_greater_text <- contr.poly(length(unique(df_results$modality))) #c(1,-1)
contrasts(df_results$modality, how.many=2) <- cbind(audio_greater_text)
```

## Entropy

### Linear mixed-effects model

Predict entropy based on modality. Conduct a contrast of audio > text

```{r}

entropy_formula <- 'entropy ~ modality + (1|word_index:task)'

# Fit the logistic mixed-effects model
model <- lmer(entropy_formula, data = df_results)

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE,  show.df = TRUE)
report (model)

plot_model(model, type=c("pred"))

```

### Task-wise effects

```{r}

# Function to extract p-values and test statistics
extract_lme_results <- function(task, df_results, formula, include_intercept = FALSE) {
  # Subset data for the specific task
  df_task <- df_results[df_results$task == task,]
  
  # Fit the linear mixed-effects model
  task_model <- lmer(formula, data = df_task, REML = TRUE)
  
  # Extract summary information
  model_summary <- summary(task_model)
  
  # Create results dataframe
  results_df <- data.frame(
    task = task,
    effect = rownames(model_summary$coefficients),
    estimate = model_summary$coefficients[, "Estimate"],
    std_error = model_summary$coefficients[, "Std. Error"],
    t_value = model_summary$coefficients[, "t value"],
    p_value = formatC(model_summary$coefficients[, "Pr(>|t|)"], format = "e", digits = 3)
  )
  
  # Optionally filter out intercept
  if (!include_intercept) {
    results_df <- results_df[results_df$effect != "(Intercept)", ]
  }
  
  return(results_df)
}

# Formula used in the original models
human_task_entropy_formula <- 'entropy ~ modality + (1|word_index)'

# List of tasks
tasks <- c('black', 'wheretheressmoke', 'howtodraw')

# Extract results for all tasks (excluding intercept by default)
results_list <- lapply(tasks, function(task) {
  extract_lme_results(task, df_results, human_task_entropy_formula)
})

# Combine results
combined_results <- do.call(rbind, results_list)

# Apply multiple comparison corrections
# Convert back to numeric for p.adjust
original_p_values <- as.numeric(as.character(combined_results$p_value))
combined_results$bonferroni_p = formatC(p.adjust(original_p_values, method = "bonferroni"), format = "e", digits = 3)
combined_results$fdr_p = formatC(p.adjust(original_p_values, method = "fdr"), format = "e", digits = 3)
combined_results$holm_p = formatC(p.adjust(original_p_values, method = "holm"), format = "e", digits = 3)

# Print corrected results
print(combined_results)

# Optional: Identify significant effects after correction
significant_bonferroni <- combined_results[as.numeric(as.character(combined_results$bonferroni_p)) < 0.05, ]
significant_fdr <- combined_results[as.numeric(as.character(combined_results$fdr_p)) < 0.05, ]
significant_holm <- combined_results[as.numeric(as.character(combined_results$holm_p)) < 0.05, ]

print("Significant effects (Bonferroni):")
print(significant_bonferroni)

print("Significant effects (FDR):")
print(significant_fdr)

print("Significant effects (Holm):")
print(significant_holm)

```

### Prosody interaction

Rerun the logistic regression with the mean prosody included as an interaction effect. 

```{r}

entropy_formula <- 'entropy ~ modality * prominence_mean + (1|word_index:task)'

# Fit the logistic mixed-effects model
model <- lmer(entropy_formula, data = df_results)

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE, show.df=TRUE)
report (model)

```

### Plot interaction model

```{r}

plot_model(model, type="pred", terms=c("prominence_mean", "modality"))

preds <- data.frame(get_model_data(model, type='pred', terms = c("prominence_mean", "modality")))

head(preds)
# 
colors <- c('#F068A1', '#82C564', '#F7CD84')

ggplot(preds, aes(x=x, y=predicted, color=group)) +
  geom_point(
    data = df_results,
    aes(x=prominence_mean, y=entropy, color=modality),
    stroke=1,
    alpha=0.1) +
  geom_line(size=1) +
  geom_ribbon(aes(ymin=conf.low, ymax=conf.high, fill=group), alpha=0.3, color=NA) +
  theme(
    aspect.ratio = 5/4,
    axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()
  ) +
  scale_color_manual(values=colors) +
  scale_fill_manual(values=colors) +
  labs(
    x = "Prosodic Prominence",
    y = "Entropy",
    title = "Prosody reduces entropy of prediction distributions")

ggsave('human_entropy-prosody-interaction.pdf', device = "pdf")
```


## Predictability

### Linear mixed-effects model

Predict accuracy based on modality 

```{r}

# df_results[df_results$predictability == 0,]$predictability <- 0.01

predictability_formula <- 'predictability ~ modality + (1|word_index:task)'

# Fit the logistic mixed-effects model
model <- glmer(predictability_formula, data=df_results, family=gaussian(link='log'))

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE,  show.df = TRUE)

plot_model(model, type='pred')
```

### Include prosody within model

```{r}


predictability_formula <- 'predictability ~ modality * prominence_mean + (1|word_index:task)'

# Fit the mixed-effects model
model <- glmer(predictability_formula, data=df_results, family=gaussian(link='log'))

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE,  show.df = TRUE)
summary(model)
# report (model)

plot_model(model, type='pred', terms=c('prominence_mean', 'modality'))
```

# Supplementary analyses

## Leakage filtering stat check

```{r}

# First filter by pvalue less than 0.05 uncorrected --> test absence of effect
df_results_filtered <- subset(df_results, df_results$barnard_pvalue >= 0.05)

# subject model for accuracy --> test if audio > text
audio_greater_text <- c(1,-1)
contrasts(df_results_filtered$modality) <- cbind(audio_greater_text)

```

### Entropy

Predict entropy based on modality. Conduct a contrast of audio > text

```{r}

entropy_formula <- 'entropy ~ modality + (1|word_index:task)'

# Fit the logistic mixed-effects model
model <- lmer(entropy_formula, data = df_results_filtered)

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE,  show.df = TRUE)
report (model)

```

### Task-wise effects

```{r}

# Formula used in the original models
human_task_entropy_formula <- 'entropy ~ modality + (1|word_index)'

# List of tasks
tasks <- c('black', 'wheretheressmoke', 'howtodraw')

# Extract results for all tasks (excluding intercept by default)
results_list <- lapply(tasks, function(task) {
  extract_lme_results(task, df_results_filtered, human_task_entropy_formula)
})

# Combine results
combined_results <- do.call(rbind, results_list)

# Apply multiple comparison corrections
# Convert back to numeric for p.adjust
original_p_values <- as.numeric(as.character(combined_results$p_value))
combined_results$bonferroni_p = formatC(p.adjust(original_p_values, method = "bonferroni"), format = "e", digits = 3)
combined_results$fdr_p = formatC(p.adjust(original_p_values, method = "fdr"), format = "e", digits = 3)
combined_results$holm_p = formatC(p.adjust(original_p_values, method = "holm"), format = "e", digits = 3)

# Print corrected results
print(combined_results)

# # Optional: Identify significant effects after correction
# significant_bonferroni <- combined_results[as.numeric(as.character(combined_results$bonferroni_p)) < 0.05, ]
# significant_fdr <- combined_results[as.numeric(as.character(combined_results$fdr_p)) < 0.05, ]
# significant_holm <- combined_results[as.numeric(as.character(combined_results$holm_p)) < 0.05, ]
# 
# print("Significant effects (Bonferroni):")
# print(significant_bonferroni)
# 
# print("Significant effects (FDR):")
# print(significant_fdr)
# 
# print("Significant effects (Holm):")
# print(significant_holm)

```

### Prosody interaction

Rerun the logistic regression with the mean prosody included as an interaction effect. 

```{r}

entropy_formula <- 'entropy ~ modality * prominence_mean + (1|word_index:task)'

# Fit the logistic mixed-effects model
model <- lmer(entropy_formula, data = df_results_filtered)

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE, show.df=TRUE)
report (model)

```

## Predictability

Predict accuracy based on modality 

```{r}

df_results_filtered[df_results_filtered$predictability == 0,]$predictability <- 0.01

predictability_formula <- 'predictability ~ modality + (1|word_index:task)'

# Fit the logistic mixed-effects model
model <- glmer(predictability_formula, data=df_results_filtered, family=gaussian(link='log'))

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE,  show.df = TRUE)

check_model(model)
```

### Include prosody within model

```{r}

predictability_formula <- 'predictability ~ modality * prominence_mean + (1|word_index:task)'

# Fit the mixed-effects model
model <- glmer(predictability_formula, data=df_results_filtered, family=gaussian(link='log'))

tab_model(model, show.se=TRUE, show.stat=TRUE, show.r2=TRUE,  show.df = TRUE)
summary(model)
# report (model)

# plot_model(model, type='pred', terms=c('prominence_mean', 'modality'))
```